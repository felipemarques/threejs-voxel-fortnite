<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Firecraft - Object Viewer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #2d3436;
            color: white;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Sidebar */
        #sidebar {
            position: absolute;
            top: 0;
            left: 0;
            width: 300px;
            height: 100vh;
            background: rgba(30, 30, 30, 0.95);
            backdrop-filter: blur(10px);
            z-index: 10;
            border-right: 1px solid #444;
            display: flex;
            flex-direction: column;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
        }

        .sidebar-header {
            padding: 20px;
            background: #111;
            border-bottom: 1px solid #444;
        }

        .sidebar-header h2 {
            margin: 0;
            font-size: 1.2rem;
            color: #00cec9;
        }

        .sidebar-header p {
            margin: 5px 0 0;
            font-size: 0.8rem;
            color: #aaa;
        }

        #categories {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .category-group {
            margin-bottom: 15px;
        }

        .category-title {
            padding: 8px 10px;
            font-weight: bold;
            color: #dfe6e9;
            text-transform: uppercase;
            font-size: 0.85rem;
            letter-spacing: 1px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            margin-bottom: 5px;
        }

        .category-title:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .object-list {
            display: none;
            padding-left: 10px;
        }

        .object-list.active {
            display: block;
        }

        .object-item {
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            margin-bottom: 2px;
            font-size: 0.9rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
        }

        .object-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .object-item.active {
            background: #0984e3;
            color: white;
            font-weight: 500;
        }

        .object-item .icon {
            margin-right: 8px;
            opacity: 0.7;
        }

        /* Controls Panel */
        #controls-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 300px;
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(5px);
            padding: 15px;
            border-radius: 8px;
            z-index: 10;
            border: 1px solid #444;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.85rem;
            color: #aaa;
        }

        .btn-group {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        button {
            background: #444;
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background 0.2s;
        }

        button:hover {
            background: #555;
        }

        button.active {
            background: #00cec9;
            color: black;
            font-weight: bold;
        }

        input[type="range"] {
            width: 100%;
        }

        /* Loading Overlay */
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #2d3436;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.5s;
            pointer-events: all;
        }

        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #00cec9;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Object Info */
        #object-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 4px;
            z-index: 5;
            text-align: right;
            pointer-events: none;
        }

        #object-name {
            font-size: 1.2rem;
            font-weight: bold;
            color: #00cec9;
            margin: 0;
        }

        #object-type {
            font-size: 0.9rem;
            color: #aaa;
            margin: 0;
        }

        .enemy-label {
            position: absolute;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-size: 14px;
            pointer-events: none;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            padding: 4px 8px;
            border-radius: 4px;
        }
    </style>
</head>

<body>

    <div id="loading">
        <div class="spinner"></div>
    </div>

    <div id="sidebar">
        <div class="sidebar-header">
            <h2>Object Viewer</h2>
            <p>Voxel Firecraft Asset Inspector</p>
        </div>
        <div id="categories">
            <!-- Categories will be populated here -->
        </div>
    </div>

    <div id="object-info">
        <h3 id="object-name">Select an Object</h3>
        <p id="object-type">No selection</p>
    </div>

    <div id="controls-panel">
        <div class="control-group" id="anim-controls" style="display: none;">
            <label>Animation</label>
            <div class="btn-group">
                <button data-anim="idle" class="active">Idle</button>
                <button data-anim="walk">Walk</button>
                <button data-anim="attack">Attack</button>
                <button data-anim="jump">Jump</button>
            </div>
        </div>

        <div class="control-group" id="anim-speed-control" style="display: none;">
            <label>Animation Speed: <span id="speed-value">1.0</span>x</label>
            <input type="range" id="anim-speed" min="0" max="2" step="0.1" value="1">
        </div>

        <div class="control-group" id="zoom-control">
            <label>Zoom Distance: <span id="zoom-value">10</span></label>
            <input type="range" id="zoom-slider" min="2" max="60" step="0.5" value="10">
        </div>

        <div class="control-group" id="vehicle-color-control" style="display: none;">
            <label>Vehicle Color</label>
            <div style="display: flex; gap: 5px; align-items: center;">
                <input type="color" id="vehicle-color" value="#1976d2">
                <button onclick="applyVehicleColor()">Apply</button>
                <button onclick="randomVehicleColor()">Random</button>
            </div>
        </div>

        <div class="control-group" id="house-color-control" style="display: none;">
            <label>Wall Color</label>
            <div style="display: flex; gap: 5px; align-items: center; margin-bottom: 8px;">
                <input type="color" id="wall-color" value="#bdc3c7">
                <button onclick="applyHouseColors()">Apply</button>
            </div>
            <label>Roof Color</label>
            <div style="display: flex; gap: 5px; align-items: center;">
                <input type="color" id="roof-color" value="#7f8c8d">
                <button onclick="applyHouseColors()">Apply</button>
            </div>
        </div>

        <div class="control-group" id="bush-scale-control" style="display: none;">
            <label>Bush Size: <span id="bush-scale-value">1.0</span>x</label>
            <input type="range" id="bush-scale" min="0.5" max="3" step="0.1" value="1.0">
            <button onclick="applyBushScale()">Apply</button>
        </div>

        <div class="control-group" id="bus-scale-control" style="display: none;">
            <label>Bus Size: <span id="bus-scale-value">1.0</span>x</label>
            <input type="range" id="bus-scale" min="0.5" max="3" step="0.1" value="1.0">
            <button onclick="applyBusScale()">Apply</button>
        </div>

        <div class="control-group" id="player-controls" style="display: none;">
            <label>Shirt Color</label>
            <div style="display: flex; gap: 5px; align-items: center; margin-bottom: 8px;">
                <input type="color" id="player-shirt-color" value="#3498db">
            </div>

            <label>Mouth Style</label>
            <select id="player-mouth" style="width: 100%; margin-bottom: 8px; padding: 4px;">
                <option value="serious">Serious</option>
                <option value="smile">Smile</option>
                <option value="angry">Angry</option>
                <option value="surprised">Surprised</option>
                <option value="none">None</option>
            </select>

            <label>Accessories</label>
            <div style="margin-bottom: 8px;">
                <label style="display: inline-flex; align-items: center; margin-right: 10px; font-weight: normal;">
                    <input type="checkbox" id="player-hat" checked> Hat
                </label>
                <label style="display: inline-flex; align-items: center; font-weight: normal;">
                    <input type="checkbox" id="player-glasses"> Glasses
                </label>
            </div>

            <label>Weapon</label>
            <select id="player-weapon" style="width: 100%; margin-bottom: 8px; padding: 4px;">
                <option value="none">None</option>
                <option value="pistol">Pistol</option>
                <option value="rifle">Rifle</option>
                <option value="smg">SMG</option>
                <option value="shotgun">Shotgun</option>
                <option value="dmr">DMR</option>
                <option value="sniper">Sniper</option>
            </select>

            <button onclick="applyPlayerSettings()">Apply Changes</button>
        </div>

        <div class="control-group" id="female-player-controls" style="display: none;">
            <label>Shirt Color</label>
            <div style="display: flex; gap: 5px; align-items: center; margin-bottom: 8px;">
                <input type="color" id="female-shirt-color" value="#E91E63">
            </div>

            <label>Hair Color</label>
            <div style="display: flex; gap: 5px; align-items: center; margin-bottom: 8px;">
                <input type="color" id="female-hair-color" value="#8B4513">
            </div>

            <label>Hair Style</label>
            <select id="female-hair-style" style="width: 100%; margin-bottom: 8px; padding: 4px;">
                <option value="long">Long</option>
                <option value="ponytail">Ponytail</option>
                <option value="bun">Bun</option>
                <option value="short">Short</option>
            </select>

            <label>Mouth Style</label>
            <select id="female-mouth" style="width: 100%; margin-bottom: 8px; padding: 4px;">
                <option value="serious">Serious</option>
                <option value="smile" selected>Smile</option>
                <option value="angry">Angry</option>
                <option value="surprised">Surprised</option>
                <option value="none">None</option>
            </select>

            <label>Accessories</label>
            <div style="margin-bottom: 8px;">
                <label style="display: inline-flex; align-items: center; margin-right: 10px; font-weight: normal;">
                    <input type="checkbox" id="female-earrings" checked> Earrings
                </label>
                <label style="display: inline-flex; align-items: center; font-weight: normal;">
                    <input type="checkbox" id="female-glasses"> Glasses
                </label>
            </div>

            <label>Weapon</label>
            <select id="female-weapon" style="width: 100%; margin-bottom: 8px; padding: 4px;">
                <option value="none">None</option>
                <option value="pistol">Pistol</option>
                <option value="rifle">Rifle</option>
                <option value="smg">SMG</option>
                <option value="shotgun">Shotgun</option>
                <option value="dmr">DMR</option>
                <option value="sniper">Sniper</option>
            </select>

            <button onclick="applyFemalePlayerSettings()">Apply Changes</button>
        </div>

        <div class="control-group">
            <label>Camera</label>
            <div class="btn-group">
                <button onclick="resetCamera()">Reset View</button>
                <button onclick="toggleRotation()">Auto Rotate</button>
            </div>
        </div>

        <div class="control-group">
            <label>Lighting</label>
            <div class="btn-group">
                <button onclick="toggleDayNight()">Day/Night</button>
            </div>
        </div>

        <div class="control-group">
            <label>Debug</label>
            <div style="margin-top: 8px;">
                <label style="display: flex; align-items: center; cursor: pointer; font-weight: normal;">
                    <input type="checkbox" id="show-bounding-box" onchange="toggleBoundingBox()"
                        style="margin-right: 8px;">
                    Show Bounding Box
                </label>
            </div>
            <div style="margin-top: 10px; border-top: 1px solid #555; padding-top: 10px;">
                <button onclick="exportGLTF()" style="width: 100%; background: #e67e22;">Export GLTF</button>
            </div>
        </div>
    </div>

    <div id="canvas-container"></div>



    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
        import { objectRegistry } from './src/objects/objectRegistry.js';

        // Static imports for build compatibility
        import * as playerMod from './src/objects/playerElement.js';
        import * as femalePlayerMod from './src/objects/femalePlayerElement.js';
        import * as vehicleMod from './src/objects/vehicleElement.js';
        import * as busMod from './src/objects/busElement.js';
        import * as motorcycleMod from './src/objects/motorcycleElement.js';
        import * as normalZombieMod from './src/objects/normalZombieElement.js';
        import * as fatZombieMod from './src/objects/fatZombieElement.js';
        import * as bigZombieMod from './src/objects/bigZombieElement.js';
        import * as slendermanMod from './src/objects/slendermanElement.js';
        import * as spiderMod from './src/objects/spiderElement.js';
        import * as houseMod from './src/objects/houseElement.js';
        import * as smallBuildingMod from './src/objects/smallBuildingElement.js';
        import * as plateauMod from './src/objects/plateauElement.js';
        import * as rockMod from './src/objects/rockElement.js';
        import * as treeOakMod from './src/objects/treeOakElement.js';
        import * as treeAlpineMod from './src/objects/treeAlpineElement.js';
        import * as bushMod from './src/objects/bushElement.js';

        const moduleMap = {
            './src/objects/playerElement.js': playerMod,
            './src/objects/femalePlayerElement.js': femalePlayerMod,
            './src/objects/vehicleElement.js': vehicleMod,
            './src/objects/busElement.js': busMod,
            './src/objects/motorcycleElement.js': motorcycleMod,
            './src/objects/normalZombieElement.js': normalZombieMod,
            './src/objects/fatZombieElement.js': fatZombieMod,
            './src/objects/bigZombieElement.js': bigZombieMod,
            './src/objects/slendermanElement.js': slendermanMod,
            './src/objects/spiderElement.js': spiderMod,
            './src/objects/houseElement.js': houseMod,
            './src/objects/smallBuildingElement.js': smallBuildingMod,
            './src/objects/plateauElement.js': plateauMod,
            './src/objects/rockElement.js': rockMod,
            './src/objects/treeOakElement.js': treeOakMod,
            './src/objects/treeAlpineElement.js': treeAlpineMod,
            './src/objects/bushElement.js': bushMod
        };

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x2d3436);
        scene.fog = new THREE.Fog(0x2d3436, 10, 60);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 4, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.target.set(0, 1, 0);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- Environment ---
        // Ground
        const groundGeo = new THREE.PlaneGeometry(60, 60);
        const groundMat = new THREE.MeshStandardMaterial({
            color: 0x3d5a80,
            roughness: 0.8,
            metalness: 0.2
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        ground.position.y = -0.01;
        scene.add(ground);

        // Grid
        const gridHelper = new THREE.GridHelper(60, 60, 0x64dfdf, 0x293241);
        scene.add(gridHelper);

        // --- State ---
        let currentObject = null;
        let currentWrapper = null;
        let currentObjDef = null; // Store current object definition for reloading with new colors
        let animationState = 'idle';
        let animSpeed = 1.0;
        let autoRotate = false;
        let isNight = false;

        // --- Animation Wrapper Class ---
        class AnimationWrapper {
            constructor(data, type) {
                this.mesh = data.mesh;
                this.type = type;
                this.baseY = this.mesh.position.y;
                this.animTime = 0;

                // Zombie properties
                this.leftArmPivot = data.leftArmPivot;
                this.rightArmPivot = data.rightArmPivot;
                this.leftLegPivot = data.leftLegPivot;
                this.rightLegPivot = data.rightLegPivot;

                // Spider properties
                this.legs = data.legs; // Array of leg pivots for spider
                this.abdomen = data.abdomen;
                this.head = data.head;
            }

            update(dt, state) {
                this.animTime += dt * 10;

                if (this.type === 'spider') {
                    this.animateSpider(state);
                } else {
                    // Zombie animations
                    if (state === 'idle') this.animateIdle();
                    else if (state === 'walk') this.animateWalk();
                    else if (state === 'attack') this.animateAttack();
                    else if (state === 'jump') this.animateJump(dt);
                }
            }

            animateSpider(state) {
                if (!this.legs) return;

                if (state === 'idle') {
                    // Idle - slow twitching front legs
                    this.legs.forEach((leg) => {
                        if (leg.index === 0) {
                            // Front legs move slowly/twitch
                            const speed = leg.side === 0 ? 1.5 : 1.2;
                            const offset = leg.side === 0 ? 0 : 1;
                            const twitch = Math.sin(this.animTime * speed + offset) * 0.2;

                            leg.upper.rotation.x = -Math.PI / 4 + twitch;
                            leg.lower.rotation.x = Math.PI / 1.2 - twitch * 0.5;
                        } else {
                            // Other legs stay mostly still, subtle breathing
                            const breathe = Math.sin(this.animTime * 0.5 + leg.index) * 0.05;
                            leg.upper.rotation.x = -Math.PI / 4 + breathe;
                            leg.lower.rotation.x = Math.PI / 1.2;
                        }
                    });

                    // Subtle body bobbing
                    this.mesh.position.y = this.baseY + Math.sin(this.animTime) * 0.02;

                } else if (state === 'walk') {
                    // Walk - stepping forward motion
                    this.legs.forEach((leg) => {
                        // Alternate diagonal pairs for walking
                        const isDiagonal1 = (leg.side + leg.index) % 2 === 0;
                        const phase = isDiagonal1 ? 0 : Math.PI;
                        const walkCycle = Math.sin(this.animTime * 2 + phase);

                        // Lift up (X rotation)
                        leg.upper.rotation.x = -Math.PI / 4 + walkCycle * 0.15;
                        leg.lower.rotation.x = Math.PI / 1.2 + walkCycle * 0.1;

                        // Step forward/back (Z rotation for forward motion)
                        // Store baseRotation in leg group during creation
                        if (leg.upper.parent) {
                            leg.upper.parent.rotation.z = walkCycle * 0.2;
                        }
                    });

                    // Body bobbing while walking
                    this.mesh.position.y = this.baseY + Math.abs(Math.sin(this.animTime * 2)) * 0.04;

                } else if (state === 'attack') {
                    // Spider attack - front legs strike forward
                    this.legs.forEach((leg) => {
                        if (leg.index === 0) { // Front legs
                            const attackPhase = (Math.sin(this.animTime * 3) + 1) / 2;

                            // Raise up
                            leg.upper.rotation.x = -Math.PI / 4 - attackPhase * 0.6;
                            leg.lower.rotation.x = Math.PI / 1.2 - attackPhase * 0.4;

                            // Strike forward (Z rotation) - reaching to grab
                            if (leg.upper.parent) {
                                leg.upper.parent.rotation.z = -attackPhase * 1.2;
                            }
                        }
                    });

                    // Raise and tilt front body forward
                    if (this.head) {
                        this.head.rotation.x = Math.sin(this.animTime * 3) * 0.3;
                    }

                } else if (state === 'jump') {
                    // Spider crouch and jump
                    const jumpCycle = Math.abs(Math.sin(this.animTime * 1));
                    this.mesh.position.y = this.baseY + jumpCycle * 2.0;

                    // Legs compress and extend
                    this.legs.forEach((leg) => {
                        const jumpPhase = Math.sin(this.animTime * 1);

                        leg.upper.rotation.x = -Math.PI / 4 + jumpPhase * 0.3;
                        leg.lower.rotation.x = Math.PI / 1.2 - jumpPhase * 0.3;
                    });
                }
            }

            animateIdle() {
                if (this.leftArmPivot) this.leftArmPivot.rotation.x = Math.sin(this.animTime) * 0.1;
                if (this.rightArmPivot) this.rightArmPivot.rotation.x = -Math.sin(this.animTime) * 0.1;
                if (this.leftLegPivot) this.leftLegPivot.rotation.x = 0;
                if (this.rightLegPivot) this.rightLegPivot.rotation.x = 0;
                this.mesh.position.y = this.baseY + Math.sin(this.animTime * 2) * 0.02;
            }

            animateWalk() {
                const angle = Math.sin(this.animTime) * 0.5;
                if (this.leftLegPivot) this.leftLegPivot.rotation.x = angle;
                if (this.rightLegPivot) this.rightLegPivot.rotation.x = -angle;
                if (this.leftArmPivot) this.leftArmPivot.rotation.x = -angle * 0.8;
                if (this.rightArmPivot) this.rightArmPivot.rotation.x = angle * 0.8;
                this.mesh.position.y = this.baseY + Math.abs(Math.sin(this.animTime)) * 0.05;
            }

            animateAttack() {
                const progress = (Math.sin(this.animTime * 3) + 1) / 2;
                const angle = -Math.PI / 2 * progress;
                if (this.leftArmPivot) this.leftArmPivot.rotation.x = angle;
                if (this.rightArmPivot) this.rightArmPivot.rotation.x = angle;
            }

            animateJump(dt) {
                // Simple jump simulation
                this.mesh.position.y = this.baseY + Math.abs(Math.sin(this.animTime * 2)) * 0.5;
            }
        }

        // --- UI Population ---
        const categoriesContainer = document.getElementById('categories');

        Object.keys(objectRegistry).forEach(category => {
            const group = document.createElement('div');
            group.className = 'category-group';

            const title = document.createElement('div');
            title.className = 'category-title';
            title.innerHTML = `<span>${category}</span> <span>${objectRegistry[category].length}</span>`;

            const list = document.createElement('div');
            list.className = 'object-list';
            if (category === 'characters') list.classList.add('active'); // Default open

            title.onclick = () => {
                document.querySelectorAll('.object-list').forEach(l => l.classList.remove('active'));
                list.classList.add('active');
            };

            // Add "View All" button for Enemies category
            if (category === 'enemies') {
                const viewAllBtn = document.createElement('div');
                viewAllBtn.className = 'object-item';
                viewAllBtn.style.background = 'rgba(100, 223, 223, 0.2)';
                viewAllBtn.style.fontWeight = 'bold';
                viewAllBtn.innerHTML = `<span class="icon">ðŸ‘¥</span> View All Enemies`;
                viewAllBtn.onclick = () => loadAllEnemies();
                list.appendChild(viewAllBtn);
            }

            objectRegistry[category].forEach(obj => {
                const item = document.createElement('div');
                item.className = 'object-item';
                item.dataset.id = obj.id; // Add ID for programmatic selection
                item.innerHTML = `<span class="icon">ðŸ“¦</span> ${obj.name}`;
                item.onclick = () => loadObject(obj);
                list.appendChild(item);
            });

            group.appendChild(title);
            group.appendChild(list);
            categoriesContainer.appendChild(group);
        });

        // --- Helper: Clear Scene ---
        function clearCurrentObjects() {
            // Clear single object
            if (currentObject) {
                scene.remove(currentObject);
                currentObject = null;
            }

            // Clear multiple objects (from View All)
            if (Array.isArray(currentWrapper)) {
                currentWrapper.forEach(wrapper => {
                    if (wrapper.mesh) scene.remove(wrapper.mesh);
                });
                currentWrapper = null;
            } else if (currentWrapper) {
                // Single wrapper
                if (currentWrapper.mesh) scene.remove(currentWrapper.mesh);
                currentWrapper = null;
            }

            // Clear labels
            document.querySelectorAll('.enemy-label').forEach(label => label.remove());
        }

        // --- Object Loading ---
        async function loadObject(objDef) {
            // Show loading
            const loadingEl = document.getElementById('loading');
            if (loadingEl) loadingEl.classList.remove('hidden');

            // Update UI
            document.querySelectorAll('.object-item').forEach(i => i.classList.remove('active'));
            if (typeof event !== 'undefined' && event && typeof event.target !== 'undefined' && event.target) {
                const targetItem = event.target.closest('.object-item');
                if (targetItem) targetItem.classList.add('active');
            }

            document.getElementById('object-name').textContent = objDef.name;
            document.getElementById('object-type').textContent = objDef.id;

            // Clear current scene state
            clearCurrentObjects();

            try {
                // Use static module map
                const module = moduleMap[objDef.module];
                if (!module) throw new Error(`Module not found in map: ${objDef.module}`);
                const createFn = module[objDef.createFn];

                if (!createFn) throw new Error(`Function ${objDef.createFn} not found in module`);

                // Create object
                const args = objDef.args || [];
                // Most create functions expect (scene, x, y, z, ...args) OR (x, z, ...args) depending on module
                // We need to handle different signatures based on the module type

                let result;
                if (objDef.id === 'car' || objDef.id === 'truck') {
                    // vehicleElement: createVehicleElement(type) - NO scene, x, y, z
                    result = createFn(...args);
                } else if (objDef.id === 'bus') {
                    // busElement: createBus(scale) - optional scale parameter
                    result = createFn(); // Will use default scale of 1.0
                } else if (objDef.id === 'motorcycle') {
                    // motorcycleElement: createMotorcycle() - NO arguments
                    result = createFn();
                } else if (objDef.id === 'player') {
                    // playerElement: createPlayer(options)
                    result = createFn({
                        shirtColor: 0x3498db,
                        mouthStyle: 'serious',
                        showHat: true,
                        showGlasses: false,
                        weapon: 'none'
                    });
                } else if (objDef.id === 'femalePlayer') {
                    // femalePlayerElement: createFemalePlayer(options)
                    result = createFn({
                        shirtColor: 0xE91E63,
                        hairColor: 0x8B4513,
                        hairStyle: 'long',
                        mouthStyle: 'smile',
                        showEarrings: true,
                        showGlasses: false,
                        weapon: 'none'
                    });
                } else if (objDef.module.includes('rockElement')) {
                    // rockElement: createRockElement(x, z, baseY)
                    result = createFn(0, 0, 0);
                } else if (objDef.module.includes('houseElement') || objDef.module.includes('smallBuildingElement') || objDef.module.includes('plateauElement')) {
                    // houseElement: createHouseElement(scale)
                    // smallBuildingElement: createSmallBuildingElement()
                    // plateauElement: createPlateauElement()
                    result = createFn(...args);
                } else if (objDef.module.includes('treeOakElement') || objDef.module.includes('treeAlpineElement') || objDef.module.includes('bushElement')) {
                    // treeOakElement: createOakTree() - NO arguments
                    // treeAlpineElement: createAlpineTree() - NO arguments
                    // bushElement: createBush() - NO arguments
                    result = createFn();
                } else {
                    // Default (Enemies): createFn(scene, 0, 0, 0)
                    // Note: Enemy functions add to scene internally, but we'll ensure it's handled
                    result = createFn(scene, 0, 0, 0, ...args);
                }

                // Handle result (could be Mesh/Group or Object with mesh property)
                // Handle result (could be Mesh/Group or Object with mesh property)
                if (result.isObject3D) {
                    // Direct THREE.Group or THREE.Mesh return (Vehicles, Buildings, Rocks)
                    currentObject = result;
                } else if (result.mesh) {
                    // Object wrapper return (Enemies)
                    currentObject = result.mesh;
                    if (objDef.animated) {
                        currentWrapper = new AnimationWrapper(result, objDef.id);
                    }
                } else {
                    console.error('Unknown object format:', result);
                    throw new Error('Object format not recognized (must be Object3D or have .mesh property)');
                }

                // Auto-align to ground
                // We want the bottom of the object to be at y=0
                const box = new THREE.Box3().setFromObject(currentObject);
                if (!box.isEmpty()) {
                    const minY = box.min.y;
                    // Shift object up so its bottom is at 0
                    currentObject.position.y -= minY;
                    currentObject.updateMatrix();
                    currentObject.updateWorldMatrix(true, true);
                }

                scene.add(currentObject);

                // Show/Hide Anim Controls
                const animControls = document.getElementById('anim-controls');
                const speedControl = document.getElementById('anim-speed-control');
                if (animControls && speedControl) {
                    if (objDef.animated) {
                        animControls.style.display = 'block';
                        speedControl.style.display = 'block';
                    } else {
                        animControls.style.display = 'none';
                        speedControl.style.display = 'none';
                    }
                }

                // UI Controls Management
                const uiControls = {
                    vehicle: document.getElementById('vehicle-color-control'),
                    house: document.getElementById('house-color-control'),
                    bush: document.getElementById('bush-scale-control'),
                    bus: document.getElementById('bus-scale-control'),
                    player: document.getElementById('player-controls'),
                    femalePlayer: document.getElementById('female-player-controls')
                };

                // Hide all special controls first
                Object.values(uiControls).forEach(el => {
                    if (el) el.style.display = 'none';
                });

                // Show appropriate controls
                if (objDef.id === 'car' || objDef.id === 'truck') {
                    if (uiControls.vehicle) uiControls.vehicle.style.display = 'block';
                } else if (objDef.module.includes('houseElement') || objDef.module.includes('smallBuildingElement') || objDef.module.includes('plateauElement')) {
                    if (uiControls.house) uiControls.house.style.display = 'block';
                } else if (objDef.module.includes('bushElement')) {
                    if (uiControls.bush) uiControls.bush.style.display = 'block';
                } else if (objDef.id === 'bus') {
                    if (uiControls.bus) uiControls.bus.style.display = 'block';
                } else if (objDef.id === 'player') {
                    if (uiControls.player) uiControls.player.style.display = 'block';
                } else if (objDef.id === 'femalePlayer') {
                    if (uiControls.femalePlayer) uiControls.femalePlayer.style.display = 'block';
                }

                // Store current object definition for color changes
                currentObjDef = objDef;

                // Fit camera
                fitCameraToObject(currentObject);

                // Override zoom for specific large objects
                const customZoomDistances = {
                    'plateau': 27,
                    'mansion': 35,
                    'smallBuilding': 21
                };

                if (customZoomDistances[objDef.id]) {
                    const box = new THREE.Box3().setFromObject(currentObject);
                    const center = box.getCenter(new THREE.Vector3());
                    const distance = customZoomDistances[objDef.id];
                    const direction = new THREE.Vector3().subVectors(camera.position, center).normalize();
                    camera.position.copy(center).add(direction.multiplyScalar(distance));
                    camera.lookAt(center);
                    controls.target.copy(center);
                    controls.update();

                    // Update zoom slider
                    const slider = document.getElementById('zoom-slider');
                    const valueSpan = document.getElementById('zoom-value');
                    if (slider && valueSpan) {
                        slider.value = distance;
                        valueSpan.textContent = distance.toFixed(1);
                    }
                }

                // Re-apply bounding box if enabled
                if (typeof toggleBoundingBox === 'function') toggleBoundingBox();

            } catch (err) {
                console.error('Error loading object:', err);
                alert('Failed to load object: ' + err.message);
            } finally {
                if (loadingEl) loadingEl.classList.add('hidden');
            }
        }

        function fitCameraToObject(object) {
            const box = new THREE.Box3().setFromObject(object);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());

            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 * Math.tan(fov * 2)); // Zoom out more

            // Minimum distance to avoid clipping
            cameraZ = Math.max(cameraZ, maxDim * 1.5);

            // Adjust for very large objects (like Plateau)
            if (maxDim > 20) cameraZ *= 1.2;

            const offset = cameraZ;

            camera.position.set(center.x + offset, center.y + offset * 0.5, center.z + offset);
            camera.lookAt(center);
            controls.target.copy(center);
            controls.update();

            // Update zoom slider
            const distance = camera.position.distanceTo(center);
            const slider = document.getElementById('zoom-slider');
            const valueSpan = document.getElementById('zoom-value');
            if (slider && valueSpan) {
                slider.value = distance;
                valueSpan.textContent = distance.toFixed(1);
            }
        }
        // --- Global Functions ---
        window.resetCamera = () => {
            if (currentObject) fitCameraToObject(currentObject);
            else {
                camera.position.set(5, 4, 5);
                controls.target.set(0, 1, 0);
            }
        };

        window.toggleRotation = () => {
            autoRotate = !autoRotate;
            controls.autoRotate = autoRotate;
        };

        window.toggleDayNight = () => {
            isNight = !isNight;
            if (isNight) {
                scene.background = new THREE.Color(0x0a0a0a);
                scene.fog.color.set(0x0a0a0a);
                ambientLight.intensity = 0.1;
                dirLight.intensity = 0.2;
            } else {
                scene.background = new THREE.Color(0x2d3436);
                scene.fog.color.set(0x2d3436);
                ambientLight.intensity = 0.6;
                dirLight.intensity = 1.0;
            }
        };

        // --- Bounding Box Toggle ---
        let boundingBoxHelper = null;

        window.toggleBoundingBox = () => {
            const checkbox = document.getElementById('show-bounding-box');

            // Remove existing box if present
            if (boundingBoxHelper) {
                scene.remove(boundingBoxHelper);
                boundingBoxHelper = null;
            }

            // Create new box if checkbox is checked
            if (checkbox.checked) {
                const box = new THREE.Box3();
                let hasObject = false;

                // Helper to expand box for an object
                const expandBox = (obj) => {
                    if (!obj) return;
                    obj.traverse(child => {
                        if (child.isMesh && child.geometry) {
                            if (!child.geometry.boundingBox) {
                                child.geometry.computeBoundingBox();
                            }
                            if (child.geometry.boundingBox) {
                                const childBox = child.geometry.boundingBox.clone();
                                child.updateWorldMatrix(true, false);
                                childBox.applyMatrix4(child.matrixWorld);
                                box.union(childBox);
                                hasObject = true;
                            }
                        }
                    });
                };

                if (Array.isArray(currentWrapper)) {
                    // Handle multiple enemies
                    currentWrapper.forEach(wrapper => {
                        if (wrapper.mesh) expandBox(wrapper.mesh);
                    });
                } else if (currentObject) {
                    // Handle single object
                    expandBox(currentObject);
                }

                // Create Box3Helper with yellow color
                if (hasObject && !box.isEmpty()) {
                    boundingBoxHelper = new THREE.Box3Helper(box, 0xffff00); // Yellow
                    scene.add(boundingBoxHelper);
                }
            }
        };

        // --- Export GLTF ---
        window.exportGLTF = () => {
            const exporter = new GLTFExporter();
            let objectToExport = currentObject;

            // Handle multiple enemies (View All)
            if (Array.isArray(currentWrapper)) {
                objectToExport = new THREE.Group();
                currentWrapper.forEach(wrapper => {
                    if (wrapper.mesh) objectToExport.add(wrapper.mesh.clone());
                });
            } else if (!objectToExport) {
                alert('No object to export!');
                return;
            } else {
                // Clone single object to avoid modifying the scene
                objectToExport = objectToExport.clone();
            }

            // Fix colors for export (remove metalness/roughness dependence on environment map)
            objectToExport.traverse((child) => {
                if (child.isMesh && child.material) {
                    // Clone material to avoid affecting the original object if it shares materials
                    // although we cloned the object, materials might still be shared references
                    const oldMat = child.material;
                    const newMat = oldMat.clone();

                    // Force non-metallic, fully rough for maximum visibility in unlit editors
                    if (newMat.metalness !== undefined) newMat.metalness = 0.0;
                    if (newMat.roughness !== undefined) newMat.roughness = 1.0;

                    child.material = newMat;
                }
            });

            exporter.parse(
                objectToExport,
                (gltf) => {
                    const blob = new Blob([gltf], { type: 'application/octet-stream' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.style.display = 'none';
                    link.href = url;
                    link.download = (currentObjDef ? currentObjDef.id : 'scene') + '.glb';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                },
                (error) => {
                    console.error('An error happened during GLTF export:', error);
                    alert('Export failed: ' + error.message);
                },
                { binary: true } // Export as binary .glb
            );
        };

        // --- Color Control Functions ---
        window.applyVehicleColor = async () => {
            if (!currentObjDef || (currentObjDef.id !== 'car' && currentObjDef.id !== 'truck')) return;

            const colorInput = document.getElementById('vehicle-color');
            const hexColor = colorInput.value;
            const numericColor = parseInt(hexColor.slice(1), 16);

            // Reload object with new color
            const modifiedDef = { ...currentObjDef, customColor: numericColor };
            await loadObjectWithColor(modifiedDef);
        };

        window.randomVehicleColor = async () => {
            if (!currentObjDef || (currentObjDef.id !== 'car' && currentObjDef.id !== 'truck')) return;

            const palette = [0x1976d2, 0xf2f2f2, 0x111111, 0x8b1a1a, 0xe53935, 0xf1c40f, 0x00bcd4, 0xff5722, 0x4caf50];
            const randomColor = palette[Math.floor(Math.random() * palette.length)];

            document.getElementById('vehicle-color').value = '#' + randomColor.toString(16).padStart(6, '0');
            await applyVehicleColor();
        };

        // Bush scale slider value display
        document.getElementById('bush-scale').addEventListener('input', (e) => {
            document.getElementById('bush-scale-value').textContent = parseFloat(e.target.value).toFixed(1);
        });

        window.applyBushScale = async () => {
            if (!currentObjDef || currentObjDef.id !== 'bush') return;

            const scaleInput = document.getElementById('bush-scale');
            const scale = parseFloat(scaleInput.value);

            // Clear current object
            if (currentObject) {
                scene.remove(currentObject);
                currentObject = null;
            }
            currentWrapper = null;

            try {
                const module = await import('./src/objects/bushElement.js');
                const createBush = module.createBush;
                const result = createBush(scale);

                currentObject = result;
                scene.add(currentObject);
                // Don't adjust camera - keep current zoom
            } catch (err) {
                console.error('Error reloading bush with scale:', err);
            }
        };

        // Bus scale slider value display
        document.getElementById('bus-scale').addEventListener('input', (e) => {
            document.getElementById('bus-scale-value').textContent = parseFloat(e.target.value).toFixed(1);
        });

        window.applyBusScale = async () => {
            if (!currentObjDef || currentObjDef.id !== 'bus') return;

            const scaleInput = document.getElementById('bus-scale');
            const scale = parseFloat(scaleInput.value);

            // Clear current object
            if (currentObject) {
                scene.remove(currentObject);
                currentObject = null;
            }
            currentWrapper = null;

            try {
                const module = await import('./src/objects/busElement.js');
                const createBus = module.createBus;
                const result = createBus(scale);

                currentObject = result;
                scene.add(currentObject);
                // Don't adjust camera - keep current zoom
            } catch (err) {
                console.error('Error reloading bus with scale:', err);
            }
        };

        window.applyPlayerSettings = async () => {
            if (!currentObjDef || currentObjDef.id !== 'player') return;

            const shirtColor = document.getElementById('player-shirt-color').value;
            const mouthStyle = document.getElementById('player-mouth').value;
            const showHat = document.getElementById('player-hat').checked;
            const showGlasses = document.getElementById('player-glasses').checked;
            const weapon = document.getElementById('player-weapon').value;

            // Clear current object
            if (currentObject) {
                scene.remove(currentObject);
                currentObject = null;
            }
            currentWrapper = null;

            try {
                const module = await import('./src/objects/playerElement.js');
                const createPlayer = module.createPlayer;

                const result = createPlayer({
                    shirtColor: parseInt(shirtColor.replace('#', '0x')),
                    mouthStyle: mouthStyle,
                    showHat: showHat,
                    showGlasses: showGlasses,
                    weapon: weapon
                });

                if (result.mesh) {
                    currentObject = result.mesh;
                    // Re-create animation wrapper to keep animations working
                    if (currentObjDef.animated) {
                        currentWrapper = new AnimationWrapper(result, currentObjDef.id);
                    }
                } else {
                    currentObject = result;
                }

                scene.add(currentObject);
                // Don't adjust camera - keep current zoom
            } catch (err) {
                console.error('Error reloading player with settings:', err);
            }
        };

        window.applyFemalePlayerSettings = async () => {
            if (!currentObjDef || currentObjDef.id !== 'femalePlayer') return;

            const shirtColor = document.getElementById('female-shirt-color').value;
            const hairColor = document.getElementById('female-hair-color').value;
            const hairStyle = document.getElementById('female-hair-style').value;
            const mouthStyle = document.getElementById('female-mouth').value;
            const showEarrings = document.getElementById('female-earrings').checked;
            const showGlasses = document.getElementById('female-glasses').checked;
            const weapon = document.getElementById('female-weapon').value;

            // Clear current object
            if (currentObject) {
                scene.remove(currentObject);
                currentObject = null;
            }
            currentWrapper = null;

            try {
                const module = await import('./src/objects/femalePlayerElement.js');
                const createFemalePlayer = module.createFemalePlayer;

                const result = createFemalePlayer({
                    shirtColor: parseInt(shirtColor.replace('#', '0x')),
                    hairColor: parseInt(hairColor.replace('#', '0x')),
                    hairStyle: hairStyle,
                    mouthStyle: mouthStyle,
                    showEarrings: showEarrings,
                    showGlasses: showGlasses,
                    weapon: weapon
                });

                if (result.mesh) {
                    currentObject = result.mesh;
                    // Re-create animation wrapper to keep animations working
                    if (currentObjDef.animated) {
                        currentWrapper = new AnimationWrapper(result, currentObjDef.id);
                    }
                } else {
                    currentObject = result;
                }

                scene.add(currentObject);
                // Don't adjust camera - keep current zoom
            } catch (err) {
                console.error('Error reloading female player with settings:', err);
            }
        };

        window.applyHouseColors = async () => {
            if (!currentObjDef || !['house', 'mansion', 'cabin'].includes(currentObjDef.id)) return;

            const wallColorInput = document.getElementById('wall-color');
            const roofColorInput = document.getElementById('roof-color');
            const wallColor = parseInt(wallColorInput.value.slice(1), 16);
            const roofColor = parseInt(roofColorInput.value.slice(1), 16);

            // Reload object with new colors
            const modifiedDef = { ...currentObjDef, customWallColor: wallColor, customRoofColor: roofColor };
            await loadObjectWithColor(modifiedDef);
        };

        async function loadObjectWithColor(objDef) {
            // Clear current object
            if (currentObject) {
                scene.remove(currentObject);
                currentObject = null;
            }
            currentWrapper = null;

            try {
                const module = await import(objDef.module);
                const createFn = module[objDef.createFn];
                const args = objDef.args || [];

                let result;
                if (objDef.id === 'car' || objDef.id === 'truck') {
                    result = createFn(args[0] || objDef.id, objDef.customColor || null);
                } else if (['house', 'mansion', 'cabin'].includes(objDef.id)) {
                    result = createFn(args[0] || 1, objDef.customWallColor, objDef.customRoofColor);
                } else {
                    // Fallback to original logic
                    return;
                }

                if (result.isObject3D) {
                    currentObject = result;
                } else if (result.mesh) {
                    currentObject = result.mesh;
                } else {
                    console.error('Unknown object format:', result);
                }

                // Auto-align to ground
                // We want the bottom of the object to be at y=0
                const box = new THREE.Box3().setFromObject(currentObject);
                if (!box.isEmpty()) {
                    const minY = box.min.y;
                    // Shift object up so its bottom is at 0
                    currentObject.position.y -= minY;
                    currentObject.updateMatrix();
                    currentObject.updateWorldMatrix(true, true);
                }

                scene.add(currentObject);
                fitCameraToObject(currentObject);
            } catch (err) {
                console.error('Error reloading object with color:', err);
            }
        };

        // --- Load All Enemies Function ---
        async function loadAllEnemies() {
            // Update UI
            document.querySelectorAll('.object-item').forEach(i => i.classList.remove('active'));
            event.target.closest('.object-item').classList.add('active');
            document.getElementById('object-name').textContent = 'All Enemies';
            document.getElementById('object-type').textContent = 'Group View';

            // Clear current scene state
            clearCurrentObjects();

            // Hide all special controls
            document.getElementById('anim-controls').style.display = 'block';
            document.getElementById('anim-speed-control').style.display = 'block';
            document.getElementById('vehicle-color-control').style.display = 'none';
            document.getElementById('house-color-control').style.display = 'none';

            try {
                // Import all enemy modules
                const { createNormalZombie } = await import('./src/objects/normalZombieElement.js');
                const { createFatZombie } = await import('./src/objects/fatZombieElement.js');
                const { createBigZombie } = await import('./src/objects/bigZombieElement.js');
                const { createSlenderman } = await import('./src/objects/slendermanElement.js');
                const { createSpider } = await import('./src/objects/spiderElement.js');

                // Create all enemies in a line
                const enemies = [];
                const zombieConfigs = [
                    { type: 'normal', x: -8, name: 'Normal Zombie', createFn: createNormalZombie },
                    { type: 'fat', x: -4, name: 'Fat Zombie', createFn: createFatZombie },
                    { type: 'big', x: 0, name: 'Big Zombie', createFn: createBigZombie },
                    { type: 'slender', x: 4, name: 'Slenderman', createFn: createSlenderman },
                    { type: 'spider', x: 8, name: 'Spider', createFn: createSpider }
                ];

                // Clear any existing labels
                document.querySelectorAll('.enemy-label').forEach(label => label.remove());

                zombieConfigs.forEach(({ type, x, name, createFn }) => {
                    const zombieData = createFn(scene, x, 0, 0);

                    // Auto-align to ground
                    const box = new THREE.Box3().setFromObject(zombieData.mesh);
                    if (!box.isEmpty()) {
                        const minY = box.min.y;
                        zombieData.mesh.position.y -= minY;
                        zombieData.mesh.updateMatrix();
                        zombieData.mesh.updateWorldMatrix(true, true);
                    }

                    const wrapper = new AnimationWrapper(zombieData, type);
                    wrapper.enemyType = type; // Store type for label positioning
                    wrapper.enemyName = name; // Store name for label text
                    enemies.push(wrapper);

                    // Create label element
                    const labelDiv = document.createElement('div');
                    labelDiv.className = 'enemy-label';
                    labelDiv.textContent = name;
                    labelDiv.id = `enemy-label-${type}`;
                    document.body.appendChild(labelDiv);
                });

                // Store enemies as current wrapper (as array)
                currentWrapper = enemies;

                // Set currentObjDef to null since this is a group view
                currentObjDef = null;

                // Reset camera to view all
                camera.position.set(0, 4, 15);
                controls.target.set(0, 2, 0);
                controls.update();

            } catch (err) {
                console.error('Error loading all enemies:', err);
                alert('Failed to load all enemies: ' + err.message);
            }
        }

        // --- Update Enemy Labels Function ---
        function updateEnemyLabels() {
            if (!Array.isArray(currentWrapper)) return;

            currentWrapper.forEach((wrapper) => {
                if (!wrapper.enemyType || !wrapper.mesh) return;

                const vector = wrapper.mesh.position.clone();
                // Different Y offsets based on enemy type
                const yOffset = wrapper.enemyType === 'slender' ? 3.5 :
                    wrapper.enemyType === 'big' ? 5 :
                        wrapper.enemyType === 'spider' ? 1.5 : 2.5;
                vector.y += yOffset;
                vector.project(camera);

                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;

                const label = document.getElementById(`enemy-label-${wrapper.enemyType}`);
                if (label) {
                    label.style.left = x + 'px';
                    label.style.top = y + 'px';
                }
            });
        }

        // --- Event Listeners ---
        document.querySelectorAll('[data-anim]').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('[data-anim]').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                animationState = e.target.dataset.anim;
            });
        });

        document.getElementById('anim-speed').addEventListener('input', (e) => {
            animSpeed = parseFloat(e.target.value);
            document.getElementById('speed-value').textContent = animSpeed.toFixed(1);
        });

        // Zoom Slider Listener
        document.getElementById('zoom-slider').addEventListener('input', (e) => {
            const dist = parseFloat(e.target.value);
            document.getElementById('zoom-value').textContent = dist.toFixed(1);

            // Move camera along the vector from target to camera
            const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
            camera.position.copy(controls.target).add(direction.multiplyScalar(dist));
            controls.update();
        });

        // Sync slider with manual zoom (mouse wheel)
        controls.addEventListener('change', () => {
            const distance = camera.position.distanceTo(controls.target);
            const slider = document.getElementById('zoom-slider');
            const valueSpan = document.getElementById('zoom-value');
            if (slider && valueSpan) {
                // Only update if not currently dragging slider (avoid conflict)
                if (document.activeElement !== slider) {
                    slider.value = distance;
                    valueSpan.textContent = distance.toFixed(1);
                }
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Animation Loop ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();

            // Handle both single enemy and multiple enemies
            if (currentWrapper && animSpeed > 0) {
                if (Array.isArray(currentWrapper)) {
                    // Multiple enemies
                    currentWrapper.forEach(wrapper => {
                        wrapper.update(dt * animSpeed, animationState);
                    });
                    // Update labels for multiple enemies
                    updateEnemyLabels();
                } else {
                    // Single enemy
                    currentWrapper.update(dt * animSpeed, animationState);
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // Initial load
        (async () => {
            const loadingEl = document.getElementById('loading');

            try {
                // Load default object (Player)
                if (objectRegistry.characters) {
                    const playerObj = objectRegistry.characters.find(o => o.id === 'player');
                    if (playerObj) {
                        console.log('Loading default object:', playerObj);
                        await loadObject(playerObj);

                        // Highlight sidebar item
                        const playerItem = document.querySelector(`.object-item[data-id="player"]`);
                        if (playerItem) {
                            document.querySelectorAll('.object-item').forEach(i => i.classList.remove('active'));
                            playerItem.classList.add('active');
                            // Ensure Characters category is open (it's the first one, usually open by default logic or we can force it)
                            // The current logic defaults 'enemies' to open, let's fix that if needed, but for now just highlighting the item is key.
                        }
                    }
                }
            } catch (err) {
                console.error('Error loading default object:', err);
            }

            // Hide loading after initial load (or if failed)
            if (loadingEl) loadingEl.classList.add('hidden');
        })();

    </script>
</body>

</html>